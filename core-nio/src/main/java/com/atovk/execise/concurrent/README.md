# java concurrent

> 分工，同步，互斥

![java-concurrent](./java-concurrent.png)

## 死锁：

> 参考来源：[source](https://blog.csdn.net/hj605635529/article/details/69214903)

我们先来思考一个问题：我们加锁以后，再次进行加锁，这样会发生什么？

当我们第二次申请锁的时候，这个时候锁已经被占用了，该线程就会被挂起，但是刚好这个线程就是拥有锁的线程了，那么这个线程就永远挂起等待了，这个我们就叫死锁。

### 1.死锁发生的情形：

（1）一个线程两次申请锁。

（2）两个线程互相申请对方的锁，但是对方都不释放锁。

### 2.死锁产生的必要条件：

（1） 互斥：一次只有一个线程可以使用一个资源。其他线程不能访问已分配给其他线程的资源。

（2）占有且等待：当一个线程在等待分配得到其他资源时，其继续占有已分配得到的资源。

（3）不可抢占：不能强行抢占其它线程中已占有的资源。

（4）循环等待：存在一个封闭的线程链，使得每个资源至少占有此链中下一个线程所需要的一个资源。

### 3.处理死锁的四种方法：

（1）死锁预防：通过确保死锁的一个必要条件不会满足，保证不会发生死锁

（2）死锁检测：允许死锁的发生，但是可以通过系统设置的检测结构及时的检测出死锁的发生，采取一些措施，将死锁清除掉

（3）死锁避免：在资源分配过程中，使用某种方法避免系统进入不安全的状态，从而避免发生死锁

（4）死锁解除：与死锁检测相配套的一种措施。当检测到系统中已发生死锁，需将进程从死锁状态中解脱出来。

常用方法：撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程。

### 4.处理死锁的具体细节：

#### 一、死锁预防：破坏死锁的四个条件中的一个或几个

(1)互斥：它是设备的固有属性所决定的，不仅不能改变，还应该加以保证。
(2)占有且等待：为预防占有且等待条件，可以要求进程一次性的请求所有需要的资源，并且阻塞这个进程直到所有请求都同时满足。这个方法比较低效。
(3)不可抢占：预防这个条件的方法：
\*如果占有某些资源的一个进程进行进一步资源请求时被拒绝，则该进程必须释放它最初占有的资源。
\*如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另外一个进程，要求它释放资源。
(4)循环等待：通过定义资源类型的线性顺序来预防。
\*如果一个进程已经分配了R类资源，那么接下来请求的资源只能是那些排在R类型之后的资源类型。该方法比较低效。

#### 二、死锁避免：

##### 两种死锁避免算法：

\*进程启动拒绝：如果一个进程的请求会导致死锁，则不启动该进程。
\*资源分配拒绝：如果一个进程增加的资源请求会导致死锁，则不允许此分配(银行家算法)。

银行家算法：
1.如果request<=need，转向步骤2；否则认为出错，因为请求资源大于需要资源。
2.如果request<=available，转向步骤3,；否则尚无足够资源，进程p阻塞；
3.系统尝试为把资源分配给进程P，并修改available、allocation和need的数值。
4.系统执行安全性算法，检查此次分配后系统是否处于安全状态，若安全，才正式将资源分配给进程P，否则将本次试探性分配作废，让进程P等待。
\*安全状态：系统能按照某种进程顺序，为每个进程分配资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利完成。

#### 三、死锁检测

一个简单的死锁检测算法：
每个进程、每个资源制定唯一编号      设定一张资源分配表，记录各进程与占用资源之间的关系      设置一张进程等待表，记录各进程与要申请资源之间的关系

*   　资源分配表

| 资源 | 进程 |
| --- | --- |
| r1 | p2 |
| r2 | p5 |
| r3 | p4 |
| r4 | p1 |
| .. | .. |

　进程等待表

| 资源 | 进程 |
| --- | --- |
| p1 | r1 |
| p2 | r3 |
| p4 | r4 |
| .. | ..

 |

分析：
p1\-r1\-p2\-r3\-p4\-r4\-p1 出现环路引起死锁

#### （四）、死锁的解除：

\*两种常用的死锁解除方法：

1) 资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。
2) 撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。

##### 银行家算法：

> 参考来源：[source](https://blog.csdn.net/L_XRUI/article/details/72935173)

每一个线程进入系统时，它必须声明在运行过程中，所需的每种资源类型最大数目，其数目不应超过系统所拥有每种资源总量，当线程请求一组资源系统必须确定有足够资源分配给该进程，若有在进一步计算这些资源分配给进程后，是否会使系统处于不安全状态，不会（即若能在分配资源时找到一个安全序列），则将资源分配给它，否则等待。

具体介绍：

假定系统中有五个线程{P0，P1，P2，P3，P4}和三类资源{A,B,C},各类资源数量分别为10,5,7,在T0时刻分配资源情况如图：

Max:表示线程对每类资源的最大需求量；

Allocation:表示系统给线程已分配每类资源的数目；

Need:表示线程还需各类资源数目；

Available:表示系统当前剩下的资源。

![](./concurrent_bank_A.jpg)

从初始找出安全序列：

(1)首先系统剩下资源{3,3,2}，查表可满足5个进程Need的进程有：P1(1,2,2)、P3(0,1,1),先给P1分配；

(2)P1分配以后执行完释放其所占资源后系统此时剩下资源有：Allocation+{3,3,2}={5,3,2};

(3)根据系统剩下资源查表可满足剩下4个进程Need的进程有P3{0,1,1}、P4{4,3,1}，再给P3分配；

(4)P3分配以后执行完释放其所占资源后系统此时剩下资源有：Allocation+{5,3,2}={7,4,3};

(5)根据系统剩下资源查表可满足剩下3个进程Need的进程有P0{7,4,3}、P2{6,0,0}、P4{4,3,1},再给P4分配；

(6)P4分配以后执行完释放其所占资源后系统此时剩下资源有：Allocation+{7,4,3}={7,4,5};

(7)根据系统剩下资源查表可满足剩下2个进程Need的进程有P0{7,4,3}、P2{6,0,0},再给P2分配;

(8)P2分配以后执行完释放其所占资源后系统此时剩下资源有：Allocation+{7,4,5}={10,4,7};

(9)根据系统剩下资源查表可满足剩下1个进程Need的进程有P0{7,4,3},最后给P0分配;

(10)P0 分配以后执行完释放其所占资源后系统此时剩下资源有：Allocation+{10,4,7}={10,5,7};

(11)所有进程按此序列{P1,P3,P4,P2,P0}可安全执行完毕，最后系统资源全部释放。（由以上也可知安全序列不唯一，但只要找出一个安全序列，说明此系统是安全的（找到安全序列可按此序列真正执行进程推进顺序，若没找到，则恢复初始状态，其并没有真正给进程分配资源，只是提前避免））

由表表示：

work:表示系统当前剩下的资源数；

 ![](./concurrent_bank_B.jpg)